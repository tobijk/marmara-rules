Description: Proposed patch for PR binutils/6412
Author: H.J. Lu  <hongjiu.lu@intel.com>
Upstream status: hjl 2.20.51.0.8
Original patch: binutils-sec64k-7.patch

bfd/

2008-04-21  H.J. Lu  <hongjiu.lu@intel.com>

	PR binutils/6412
	* bfd.c (bfd): Add has_gap_in_elf_shndx.
	* bfd-in2.h: Regenerated.

	* bfd-in.h (bfd_has_gap_in_elf_shndx): New.

	* elf.c (setup_group): Handle gap in section indices.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	(elf_object_p): Likewise.  Use %B where reporting corrupt
	string table index.

include/elf/

2008-04-21  H.J. Lu  <hongjiu.lu@intel.com>

	PR binutils/6412
	* internal.h (ELF_SECTION_HEADER_INDEX_GAP): New.

binutils/

2008-04-21  H.J. Lu  <hongjiu.lu@intel.com>

	PR binutils/6412
	* readelf.c (hole_in_shndx): New.
	(original_shndx_info): Likewise.
	(original_shndx): Likewise.
	(process_file_header): Move ELF magic bytes check to ...
	(get_file_header): Here.
	(get_32bit_section_headers): Set hole_in_shndx if sh_link
	>= number of sections.
	(get_64bit_section_headers): Likewise.
	(get_32bit_elf_symbols): Adjust st_shndx if hole_in_shndx
	isn't 0.
	(get_64bit_elf_symbols): Likewise.
	(process_section_headers): Adjust elf_header.e_shstrndx,
	sh_link and sh_info, save original sh_link and sh_info,
	display adjustment for sh_link and sh_info if hole_in_shndx
	isn't 0.
	(process_section_groups): Adjust member section index if
	hole_in_shndx isn't 0.
	(process_object): Free original_shndx if needed.

--- a/bfd/bfd-in.h
+++ b/bfd/bfd-in.h
@@ -497,6 +497,7 @@
 #define bfd_my_archive(abfd) ((abfd)->my_archive)
 #define bfd_has_map(abfd) ((abfd)->has_armap)
 #define bfd_is_thin_archive(abfd) ((abfd)->is_thin_archive)
+#define bfd_has_gap_in_elf_shndx(abfd) ((abfd)->has_gap_in_elf_shndx)
 
 #define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
 #define bfd_usrdata(abfd) ((abfd)->usrdata)
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -504,6 +504,7 @@
 #define bfd_my_archive(abfd) ((abfd)->my_archive)
 #define bfd_has_map(abfd) ((abfd)->has_armap)
 #define bfd_is_thin_archive(abfd) ((abfd)->is_thin_archive)
+#define bfd_has_gap_in_elf_shndx(abfd) ((abfd)->has_gap_in_elf_shndx)
 
 #define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
 #define bfd_usrdata(abfd) ((abfd)->usrdata)
@@ -5196,6 +5197,9 @@
   /* Set if only required symbols should be added in the link hash table for
      this object.  Used by VMS linkers.  */
   unsigned int selective_search : 1;
+
+  /* Set if there is a gap in ELF section index.  */
+  unsigned int has_gap_in_elf_shndx : 1;
 };
 
 typedef enum bfd_error
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -290,6 +290,9 @@
 .  {* Set if only required symbols should be added in the link hash table for
 .     this object.  Used by VMS linkers.  *}
 .  unsigned int selective_search : 1;
+.
+.  {* Set if there is a gap in ELF section index.  *}
+.  unsigned int has_gap_in_elf_shndx : 1;
 .};
 .
 */
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -632,6 +632,12 @@
 			      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
 			  break;
 			}
+
+		      /* Handle gap in section indices.  */
+		      if (bfd_has_gap_in_elf_shndx (abfd)
+			  && idx > (SHN_HIRESERVE & 0xffff))
+			idx -= ELF_SECTION_HEADER_INDEX_GAP;
+
 		      if (idx >= shnum)
 			{
 			  ((*_bfd_error_handler)
--- a/bfd/elfcode.h
+++ b/bfd/elfcode.h
@@ -195,6 +195,10 @@
       if (shndx == NULL)
 	return FALSE;
       dst->st_shndx = H_GET_32 (abfd, shndx->est_shndx);
+      /* Handle gap in section indices.  */
+      if (bfd_has_gap_in_elf_shndx (abfd)
+	  && dst->st_shndx > (SHN_HIRESERVE & 0xffff))
+	dst->st_shndx -= ELF_SECTION_HEADER_INDEX_GAP;
     }
   else if (dst->st_shndx >= (SHN_LORESERVE & 0xffff))
     dst->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
@@ -815,6 +819,28 @@
 		  != 0))
 	    abfd->flags &= ~D_PAGED;
 	}
+
+      /* To support files generated by the older linker, we adjust
+	 section indices if there is a gap.  */
+      if (bfd_has_gap_in_elf_shndx (abfd))
+	{
+	  BFD_ASSERT (i_ehdrp->e_shstrndx == i_shdrp->sh_link);
+
+	  for (; num_sec > 0; num_sec--, i_shdrp++)
+	    {
+	      if (i_shdrp->sh_link > (SHN_HIRESERVE & 0xffff))
+		i_shdrp->sh_link -= ELF_SECTION_HEADER_INDEX_GAP;
+
+	      if (i_shdrp->sh_info > (SHN_HIRESERVE & 0xffff)
+		  && ((i_shdrp->sh_flags & SHF_INFO_LINK)
+		      || i_shdrp->sh_type == SHT_RELA
+		      || i_shdrp->sh_type == SHT_REL))
+		i_shdrp->sh_info -= ELF_SECTION_HEADER_INDEX_GAP;
+	    }
+
+	  if (i_ehdrp->e_shstrndx > (SHN_HIRESERVE & 0xffff))
+	    i_ehdrp->e_shstrndx -= ELF_SECTION_HEADER_INDEX_GAP;
+	}
     }
 
   /* A further sanity check.  */
@@ -829,7 +855,8 @@
 	     So we are kind, and reset the string index value to 0
 	     so that at least some processing can be done.  */
 	  i_ehdrp->e_shstrndx = SHN_UNDEF;
-	  _bfd_error_handler (_("warning: %s has a corrupt string table index - ignoring"), abfd->filename);
+	  _bfd_error_handler (_("warning: %B has a corrupt string table index - ignoring"),
+			      abfd);
 	}
     }
   else if (i_ehdrp->e_shstrndx != SHN_UNDEF)
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -198,6 +198,15 @@
 static int do_archive_index;
 static int is_32bit_elf;
 
+struct original_shndx_info
+{
+  unsigned int sh_link;
+  unsigned int sh_info;
+};
+static struct original_shndx_info *original_shndx;
+/* The largest section index in sh_link if it isn't 0.  */
+static unsigned int hole_in_shndx;
+
 struct group_list
 {
   struct group_list * next;
@@ -3485,16 +3494,6 @@
 static int
 process_file_header (void)
 {
-  if (   elf_header.e_ident[EI_MAG0] != ELFMAG0
-      || elf_header.e_ident[EI_MAG1] != ELFMAG1
-      || elf_header.e_ident[EI_MAG2] != ELFMAG2
-      || elf_header.e_ident[EI_MAG3] != ELFMAG3)
-    {
-      error
-	(_("Not an ELF file - it has the wrong magic bytes at the start\n"));
-      return 0;
-    }
-
   init_dwarf_regnames (elf_header.e_machine);
 
   if (do_header)
@@ -3993,6 +3992,10 @@
       internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
       internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
       internal->sh_entsize   = BYTE_GET (shdrs[i].sh_entsize);
+      /* The older linker generates section header indices with
+	 hole.  */
+      if (i > 0 && internal->sh_link >= elf_header.e_shnum)
+	hole_in_shndx = internal->sh_link;
     }
 
   free (shdrs);
@@ -4036,6 +4039,10 @@
       internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
       internal->sh_offset    = BYTE_GET (shdrs[i].sh_offset);
       internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
+      /* The older linker generates section header indices with
+	 hole.  */
+      if (i > 0 && internal->sh_link >= elf_header.e_shnum)
+	hole_in_shndx = internal->sh_link;
     }
 
   free (shdrs);
@@ -4101,8 +4108,12 @@
       psym->st_size  = BYTE_GET (esyms[j].st_size);
       psym->st_shndx = BYTE_GET (esyms[j].st_shndx);
       if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
-	psym->st_shndx
-	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
+	{
+	  psym->st_shndx
+	    = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
+	  if (hole_in_shndx && psym->st_shndx > (SHN_HIRESERVE & 0xffff))
+	    psym->st_shndx -= ELF_SECTION_HEADER_INDEX_GAP;
+	}
       else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
 	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
       psym->st_info  = BYTE_GET (esyms[j].st_info);
@@ -4184,8 +4195,12 @@
       psym->st_other = BYTE_GET (esyms[j].st_other);
       psym->st_shndx = BYTE_GET (esyms[j].st_shndx);
       if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
-	psym->st_shndx
-	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
+	{
+	  psym->st_shndx
+	    = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
+	  if (hole_in_shndx && psym->st_shndx > (SHN_HIRESERVE & 0xffff))
+	    psym->st_shndx -= ELF_SECTION_HEADER_INDEX_GAP;
+	}
       else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
 	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
       psym->st_value = BYTE_GET (esyms[j].st_value);
@@ -4433,6 +4448,7 @@
   unsigned int i;
 
   section_headers = NULL;
+  original_shndx = NULL;
 
   if (elf_header.e_shnum == 0)
     {
@@ -4454,6 +4470,44 @@
   else if (! get_64bit_section_headers (file, elf_header.e_shnum))
     return 0;
 
+  if (hole_in_shndx
+      && ((hole_in_shndx - ELF_SECTION_HEADER_INDEX_GAP)
+	  < elf_header.e_shnum))
+    {
+      Elf_Internal_Shdr *internal;
+      struct original_shndx_info *p;
+
+      if (elf_header.e_shstrndx > (SHN_HIRESERVE & 0xffff))
+	elf_header.e_shstrndx -= ELF_SECTION_HEADER_INDEX_GAP;
+
+      original_shndx = cmalloc (elf_header.e_shnum, 
+				sizeof (*original_shndx));
+      if (original_shndx == NULL)
+	{
+	  error (_("Out of memory\n"));
+	  return 0;
+	}
+
+      internal = section_headers;
+      p = original_shndx;
+      for (i = elf_header.e_shnum;
+	   i > 0;
+	   i--, internal++, p++)
+	{
+	  p->sh_link = internal->sh_link;
+	  p->sh_info = internal->sh_info;
+
+	  if (internal->sh_link > (SHN_HIRESERVE & 0xffff))
+	    internal->sh_link -= ELF_SECTION_HEADER_INDEX_GAP;
+
+	  if (internal->sh_info > (SHN_HIRESERVE & 0xffff)
+	      && (internal->sh_flags & SHF_INFO_LINK
+		  || internal->sh_type == SHT_REL
+		  || internal->sh_type == SHT_RELA))
+	    internal->sh_info -= ELF_SECTION_HEADER_INDEX_GAP;
+	}
+    }
+
   /* Read in the string table, so that we have names to display.  */
   if (elf_header.e_shstrndx != SHN_UNDEF
        && elf_header.e_shstrndx < elf_header.e_shnum)
@@ -4750,7 +4804,23 @@
 		}
 	    }
 
-	  if (do_section_details)
+	  if (hole_in_shndx && original_shndx)
+	    {
+	      if (original_shndx[i].sh_link != section->sh_link)
+		printf ("%2u/-%3u ",
+			original_shndx[i].sh_link,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("%2u ", section->sh_link);
+	      if (original_shndx[i].sh_info != section->sh_info)
+		printf ("%3u/-%3u ",
+			original_shndx[i].sh_info,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("%3u ", section->sh_info);
+	      printf ("%2lu\n", (unsigned long) section->sh_addralign);
+	    }
+	  else if (do_section_details)
 	    {
 	      if (link_too_big != NULL && * link_too_big)
 		printf ("<%s> ", link_too_big);
@@ -4802,7 +4872,23 @@
 	  else
 	    printf (" %3s ", get_elf_section_flags (section->sh_flags));
 
-	  printf ("%2u %3u ", section->sh_link, section->sh_info);
+	  if (hole_in_shndx)
+	    {
+	      if (original_shndx[i].sh_link != section->sh_link)
+		printf ("%2u/-%3u ",
+			original_shndx[i].sh_link,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("%2u ", section->sh_link);
+	      if (original_shndx[i].sh_info != section->sh_info)
+		printf ("%3u/-%3u ",
+			original_shndx[i].sh_info,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("%3u ", section->sh_info);
+	    }
+	  else
+	    printf ("%2u %3u ", section->sh_link, section->sh_info);
 
 	  if ((unsigned long) section->sh_addralign == section->sh_addralign)
 	    printf ("%2lu\n", (unsigned long) section->sh_addralign);
@@ -4824,14 +4910,35 @@
 	      printf ("  ");
 	      print_vma (section->sh_offset, LONG_HEX);
 	    }
-	  printf ("  %u\n       ", section->sh_link);
+	  if (hole_in_shndx)
+	    {
+	      if (original_shndx[i].sh_link != section->sh_link)
+		printf ("  %u/-%3u\n       ",
+			original_shndx[i].sh_link,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("  %u\n       ", section->sh_link);
+	    }
+	  else
+	    printf ("  %u\n       ", section->sh_link);
 	  print_vma (section->sh_size, LONG_HEX);
 	  putchar (' ');
 	  print_vma (section->sh_entsize, LONG_HEX);
 
-	  printf ("  %-16u  %lu\n",
-		  section->sh_info,
-		  (unsigned long) section->sh_addralign);
+	  if (hole_in_shndx)
+	    {
+	      if (original_shndx[i].sh_info != section->sh_info)
+		printf ("  %-11u/-%3u",
+			original_shndx[i].sh_info,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("  %-16u", section->sh_info);
+	      printf ("  %lu\n", (unsigned long) section->sh_addralign);
+	    }
+	  else
+	    printf ("  %-16u  %lu\n",
+		    section->sh_info,
+		    (unsigned long) section->sh_addralign);
 	}
       else
 	{
@@ -4851,10 +4958,28 @@
 
 	  printf (" %3s ", get_elf_section_flags (section->sh_flags));
 
-	  printf ("     %2u   %3u     %lu\n",
-		  section->sh_link,
-		  section->sh_info,
-		  (unsigned long) section->sh_addralign);
+	  if (hole_in_shndx)
+	    {
+	      if (original_shndx[i].sh_link != section->sh_link)
+		printf ("  %2u/-%3u",
+			original_shndx[i].sh_link,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("     %2u", section->sh_link);
+	      if (original_shndx[i].sh_info != section->sh_info)
+		printf (" %3u/-%3u",
+			original_shndx[i].sh_info,
+			ELF_SECTION_HEADER_INDEX_GAP);
+	      else
+		printf ("   %3u", section->sh_info);
+	      printf ("     %lu\n",
+		      (unsigned long) section->sh_addralign);
+	    }
+	  else
+	    printf ("     %2u   %3u     %lu\n",
+		    section->sh_link,
+		    section->sh_info,
+		    (unsigned long) section->sh_addralign);
 	}
 
       if (do_section_details)
@@ -5069,10 +5194,15 @@
 	  for (j = 0; j < size; j++)
 	    {
 	      struct group_list * g;
+	      unsigned int orig;
 
 	      entry = byte_get (indices, 4);
 	      indices += 4;
 
+	      orig = entry;
+	      if (hole_in_shndx && entry > (SHN_HIRESERVE & 0xffff))
+		entry -= ELF_SECTION_HEADER_INDEX_GAP;
+
 	      if (entry >= elf_header.e_shnum)
 		{
 		  error (_("section [%5u] in group section [%5u] > maximum section [%5u]\n"),
@@ -5109,7 +5239,13 @@
 	      if (do_section_groups)
 		{
 		  sec = section_headers + entry;
-		  printf ("   [%5u]   %s\n", entry, SECTION_NAME (sec));
+		  if (orig != entry)
+		    printf ("   [%5u/-%3u]   %s\n",
+			    orig, ELF_SECTION_HEADER_INDEX_GAP,
+			    SECTION_NAME (sec));
+		  else
+		    printf ("   [%5u]   %s\n",
+			    entry, SECTION_NAME (sec));
 		}
 
 	      g = (struct group_list *) xmalloc (sizeof (struct group_list));
@@ -12086,6 +12222,15 @@
   if (fread (elf_header.e_ident, EI_NIDENT, 1, file) != 1)
     return 0;
 
+  if (elf_header.e_ident[EI_MAG0] != ELFMAG0
+      || elf_header.e_ident[EI_MAG1] != ELFMAG1
+      || elf_header.e_ident[EI_MAG2] != ELFMAG2
+      || elf_header.e_ident[EI_MAG3] != ELFMAG3)
+    {
+      error (_("Not an ELF file - it has the wrong magic bytes at the start\n"));
+      return 0;
+    }
+
   /* Determine how to read the rest of the header.  */
   switch (elf_header.e_ident[EI_DATA])
     {
@@ -12181,6 +12326,8 @@
 {
   unsigned int i;
 
+  hole_in_shndx = 0;
+
   if (! get_file_header (file))
     {
       error (_("%s: Failed to read file header\n"), file_name);
@@ -12268,6 +12415,12 @@
       section_headers = NULL;
     }
 
+  if (original_shndx)
+    {
+      free (original_shndx);
+      original_shndx = NULL; 
+    }
+
   if (string_table)
     {
       free (string_table);
--- a/include/elf/internal.h
+++ b/include/elf/internal.h
@@ -342,4 +342,8 @@
 #define ELF_SECTION_IN_SEGMENT_STRICT(sec_hdr, segment)			\
   (ELF_SECTION_IN_SEGMENT_1 (sec_hdr, segment, 1, 1))
 
+/* The gap in section indices created by the older linker before
+   bug fix for PR ld/5900.  */
+#define ELF_SECTION_HEADER_INDEX_GAP (SHN_HIRESERVE + 1 - SHN_LORESERVE)
+
 #endif /* _ELF_INTERNAL_H */
